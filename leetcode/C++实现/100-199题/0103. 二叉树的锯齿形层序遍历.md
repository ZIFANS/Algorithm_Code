# Python 

```python
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        
        ans, q = [], collections.deque()
        q.append(root)

        while q:
            count, height = 0, len(q)
            level = []

            for count in range(height):
                temp = q.popleft()
                level.append(temp.val)

                if temp.left:
                    q.append(temp.left)
                if temp.right:
                    q.append(temp.right)
                
            ans.append(level[::-1] if len(ans) % 2 else level)

        return ans
```


# JavaScript

```js
// 别人的思想：
// 第一层奇数，第二层偶数。奇数从左到右，偶数从右到左
var zigzagLevelOrder = function(root) {
    if(!root)
        return [];
    let ans = [], lRoot = [], rRoot = [];
    lRoot.push(root);
    while(lRoot.length !== 0 || rRoot.length !== 0) {
        let temp = [];
        if(lRoot.length !== 0) {
            while(lRoot.length !== 0) {
                let cur = lRoot.pop();  
                temp.push(cur.val);
                if(cur.left !== null)   // 这是是在第1,3,5..层吧遍历，将下一层从左子树到右子树入栈
                    rRoot.push(cur.left);
                if(cur.right !== null)   
                    rRoot.push(cur.right);
            }
        }
        else if(rRoot.length !== 0) {
            while(rRoot.length !== 0) {
                let cur = rRoot.pop();
                temp.push(cur.val);
                if(cur.right !== null)   // 这是是在第2,4,6..层吧遍历，将下一层从右子树到左子树入栈
                    lRoot.push(cur.right);
                if(cur.left !== null)   
                    lRoot.push(cur.left);
            }
        }
        ans.push(temp);
    }
    return ans;
};
```

# C++

```C++
```

