
```
本问题要求我们返回字符串SS 中包含字符串TT的全部字符的最小窗口。我们称包含TT的全部字母的窗口为可行窗口。

可以用简单的滑动窗口法来解决本问题。

在滑动窗口类型的问题中都会有两个指针。一个用于延伸现有窗口的 rightright指针，和一个用于收缩窗口的leftleft 指针。在任意时刻，只有一个指针运动，而另一个保持静止。

本题的解法很符合直觉。我们通过移动right指针不断扩张窗口。当窗口包含全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。

答案是最小的可行窗口。
```

算法：

```
1、初始，leftleft指针和rightright指针都指向SS的第一个元素.

2、将 rightright 指针右移，扩张窗口，直到得到一个可行窗口，亦即包含TT的全部字母的窗口。

3、得到可行的窗口后，将lefttleftt指针逐个右移，若得到的窗口依然可行，则更新最小窗口大小。

4、若窗口不再可行，则跳转至 22。

```

实现：

```js
var minWindow = function(s, t) {
    let ans = '';
    let left = 0, right = 0;
    let needs = {};
    let windows = {};
    let match = 0, start = 0, minLen = Number.MAX_SAFE_INTEGER;
    for (let i = 0; i < t.length; ++i) {
        needs[t[i]] ? needs[t[i]]++ : needs[t[i]] = 1;
    }
    let needsLen = Object.keys(needs).length;
    while(right < s.length) {
        let c1 = s[right];
        if (needs[c1]) {
            windows[c1] ? windows[c1]++ : windows[c1] = 1;
            if (windows[c1] == needs[c1]) {
                match++;
            }
        }
        right++;
        while (match === needsLen) {
            if (right - left < minLen) {
                start = left;
                minLen = right - left;
            }
            let c2 = s[left];
            if (needs[c2]) {
                windows[c2]--;
                if (windows[c2] < needs[c2]) {
                    match--;
                }
            }
            ++left;
        }
    }
    return minLen === Number.MAX_SAFE_INTEGER ? '' : s.substr(start, minLen);
};
```