- 状态定义：

dp[i]dp[i] 的值代表 nums 前 ii 个数字的最长子序列长度。

- 转移方程： 设 j∈[0,i)j∈[0,i)，考虑每轮计算新 dp[i]dp[i] 时，遍历 [0,i)[0,i) 列表区间，做以下判断：

    - 1、当 nums[i] > nums[j]nums[i]>nums[j] 时： nums[i]nums[i] 可以接在 nums[j]nums[j] 之后（此题要求严格递增），此情况下最长上升子序列长度为 dp[j] + 1dp[j]+1 ；
 
    - 2、当 nums[i] <= nums[j]nums[i]<=nums[j] 时： nums[i]nums[i] 无法接在 nums[j]nums[j] 之后，此情况上升子序列不成立，跳过。

    - 上述所有 1. 情况 下计算出的 dp[j] + 1dp[j]+1 的最大值，为直到 ii 的最长上升子序列长度（即 dp[i]dp[i] ）。实现方式为遍历 jj 时，每轮执行 dp[i] = max(dp[i], dp[j] + 1)dp[i]=max(dp[i],dp[j]+1)。

    - 转移方程： dp[i] = max(dp[i], dp[j] + 1) for j in [0, i)。

- 初始状态：

dp[i]dp[i] 所有元素置 11，含义是每个元素都至少可以单独成为子序列，此时长度都为 11。
返回值：

- 返回值
返回 dpdp 列表最大值，即可得到全局最长上升子序列长度。


实现
```js
var lengthOfLIS = function(nums) {
    let len = nums.length;
    if (len === 0)
        return 0;
    let ans = 0
    let dp = new Array(len).fill(1);
    for (let i = 0; i < len; ++i) {
        for (let j = 0; j < i; ++j) {
            if (nums[j] < nums[i])
                dp[i] = Math.max(dp[i], dp[j] + 1);
        }
        ans = Math.max(ans, dp[i]);
    }
    return ans;
};
```