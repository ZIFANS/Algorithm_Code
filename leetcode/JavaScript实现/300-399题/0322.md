自己最开始的一种错误解法：

其实是贪心算法，将数组从大到小排序。但是这样的策略有问题：

如果我们换一组钞票面值，比如 1， 5， 11，我们要凑出15的时候， 贪心策略就会出错：

15 = 11 * 1 + 1 * 4 (贪心策略）

15 = 5 * 3（正确策略）

```js
var coinChange = function(coins, amount) {
    let ans = -1, len = coins.length;
    // 从大到小排序
    coins.sort((a, b) => {
        return b - a;
    });
    let tempAns = new Array(len).fill(0);
    for (let i = 0; i < len; ++i) {
        let countNum = Math.trunc(amount / coins[i]);
        tempAns[i] = countNum;
        amount = amount % coins[i];
    }
    let sum = 0;
    tempAns.forEach(function(val, index, tempAns) {
        return sum += val;
    });
    ans = sum;
    return ans;
};
```

正确的动态规划解法：

思路：

```
假设你是个土豪，你有1，5，10，20，50，100的钞票，你要凑出666买瓶水喝，依据生活经验，我们一般采取这样的策略：能用100就用100的，否则就用50的，依此类推，在这种策略下，666=100*6 + 50 1 + 10 1 + 51 + 11, 一共用了10张钞票。

这种策略就称为 贪心策略 ：贪心策略是在当前情况下做出最好的选择，根据需要凑出的金额来进行贪心，但是，如果我们换一组钞票面值，比如 1， 5， 11，我们要凑出15的时候， 贪心策略就会出错：

15 = 11 * 1 + 1 * 4 (贪心策略）
15 = 5 * 3（正确策略）
贪心策略哪里出错了？
鼠目寸光

重新分析刚刚的例子。w=15时，我们如果取11，接下来就面对w=4的情况；如果取5，则接下来面对w=10的情况。我们发现这些问题都有相同的形式：“给定w，凑出w所用的最少钞票是多少张？” 接下来，我们用f(n)来表示“凑出n所需的最少钞票数量”。　　
那么，如果我们取了11，最后的代价（用掉的钞票总数）是多少呢？
　　
明显 ，它的意义是：利用11来凑出15，付出的代价等于f(4)加上自己这一张钞票。现在我们暂时不管f(4)怎么求出来。
依次类推，马上可以知道：如果我们用5来凑出15，cost就是f(10) + 1 = 2 + 1 = 3 。　
　那么，现在w=15的时候，我们该取那种钞票呢？当然是各种方案中，cost值最低的那一个
- 取11：　cost=f(4)+1=4+1=5　
- 取5： 　 cost = f(10) + 1 = 2 + 1 = 3
- 取1： 　cost = f(14) + 1 = 4 + 1 = 5
显而易见，cost值最低的是取5的方案。我们通过上面三个式子，做出了正确的决策!
这给了我们一个至关重要的启示—— 只与 相关；更确切地说： f(n) 只与 f(n-1),f(n-5),f(n-11) 相关；更确切地说：
f(n)=min{f(n-1),f(n-5),f(n-11)}+1
````

```js
var coinChange = function(coins, amount) {
    let len = coins.length;
    let dp = new Array(len + 1);
    dp[0] = 0;
    for (let i = 1; i <= amount; ++i) {
        let cost = Number.MAX_VALUE;
        for (let j = 0; j < len; ++j) {
            if (i - coins[j] >= 0) {
                if (dp[i - coins[j]] !== Number.MAX_VALUE)
                    cost = Math.min(cost, dp[i - coins[j]] + 1);
            }
        }
        dp[i] = cost;
    }
    return  dp[amount] == Number.MAX_VALUE? -1 : dp[amount];
};
```


```
动态规划算法思想： 将一个大问题分解成多个小问题，分别求解小问题，大问题的解可以由小问题的推出。
```